- [网络模型](#网络模型)
  - [OSI](#osi)
  - [TCP/IP 五层协议](#tcpip-五层协议)
- [物理层](#物理层)
- [数据链路层](#数据链路层)
  - [以太网协议](#以太网协议)
  - [MAC 地址](#mac-地址)
  - [广播](#广播)
- [网络层](#网络层)
  - [IP（网际协议）](#ip网际协议)
    - [IP 数据包](#ip-数据包)
    - [IP 地址分类](#ip-地址分类)
  - [ARP（地址解析协议）](#arp地址解析协议)
- [传输层](#传输层)
  - [UDP（用户数据报协议）](#udp用户数据报协议)
  - [TCP（传输控制协议）](#tcp传输控制协议)
- [应用层](#应用层)
  - [HTTP（超文本传输协议）](#http超文本传输协议)
    - [URI](#uri)
    - [HTTP1.0](#http10)
    - [HTTP1.1](#http11)
    - [HTTP2.0](#http20)
    - [HTTP3.0](#http30)
  - [HTTPS（超文本传输安全协议）](#https超文本传输安全协议)
    - [TLS/SSL](#tlsssl)
  - [DNS（域名系统）](#dns域名系统)
    - [DNS 同时使用 TCP 和 UDP 协议](#dns-同时使用-tcp-和-udp-协议)
    - [DNS 的查询方式](#dns-的查询方式)
    - [DNS 的完整查询过程](#dns-的完整查询过程)
  - [WebSocket](#websocket)
  - [CDN](#cdn)
    - [CDN 的基本原理](#cdn-的基本原理)
- [附录一 常见请求头](#附录一-常见请求头)
- [附录二 常见响应头](#附录二-常见响应头)
- [附录三 常见状态码](#附录三-常见状态码)
- [参考资料](#参考资料)

# 网络模型

## OSI

OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰。
![OSI](./images/computer_network/OSI.png)

传输过程：
![OSI_transmission_process](./images/computer_network/OSI_transmission_process.png)

## TCP/IP 五层协议

TCP/IP，传输控制协议/网际协议，是指能够在多个不同网络间实现信息传输的协议簇，TCP/IP 协议不仅仅指的是 TCP 和 IP 两个协议，而是指一个由 FTP、SMTP、TCP、UDP、IP 等协议构成的协议簇，只是因为在 TCP/IP 协议中 TCP 协议和 IP 协议最具代表性，所以通称为 TCP/IP 协议族（英语：TCP/IP Protocol Suite，或 TCP/IP Protocols）。

TCP/IP 体系分类：

- 五层体系

  五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层，五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。

- 四层体系

  | 层次名称 | 单位 | 功能 | 协议 |
  | --- | --- | --- | ---|
  | 应用层 | 报文 | 负责实现一切与应用程序相关的功能，对应 OSI 参考模型的上三层 | FTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议） SMTP（简单邮件传输协议） NFS（网络文件系统协议）|
  | 传输层 | 报文段 | 负责提供可靠的传输服务，对应 OSI 参考模型的第四层 | TCP（传输控制协议） UDP（用户数据报协议）|
  | 网络层 | 数据报 | 负责网络间的寻址数据传输，对应 OSI 参考模型的第三层） | IP（网际协议） ICMP（网际控制消息协议） ARP（地址解析协议） RARP（逆地址解析协议） |
  | 网络接口层 | 帧 | 负责实际数据的传输，对应 OSI 参考模型的下两层 | HDLC（高级链路控制协议） PPP（点对点协议） SLIP（串行线路接口协议） |

  传输过程：
  ![TCP/IP_transmission_process](./images/computer_network/TCP_IP_transmission_process.png)

OSI 参考模型与 TCP/IP 参考模型对比：

- 相同点：

  - OSI 参考模型与 TCP/IP 参考模型都采用了层次结构。

  - 都能够提供面向连接和无连接两种通信服务机制。

- 不同点：

  - TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。

  - OSI 参考模型虽然网络划分为七层，但实现起来较困难。TCP/IP 参考模型作为一种简化的分层结构是可以的。

  - TCP/IP 协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的。

# 物理层

物理层做的是用物理手段把电脑连接起来，如光缆、电缆、双绞线等。

**功能：负责传输 0 和 1 的电信号。**

# 数据链路层

**功能：确定 0 和 1 的分组方式。**

## 以太网协议

早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一个叫以太网的协议，占据了主导地位。

以太网规定，一组电信号构成一个数据包，叫做**帧（Frame）**。每一帧分成两个部分：**首部（Head）**和**数据（Data）**。

| 以太网首部 | 数据 |

**首部**包含数据包的一些说明项，比如发送者、接受者、数据类型等等；**数据**则是数据包的具体内容。

**首部**的长度，固定为 18 字节。**数据**的长度，最短为 46 字节，最长为 1500 字节。因此，整个**帧**最短为 64 字节，最长为 1518 字节。如果数据很长，就必须分割成多个帧进行发送。

## MAC 地址

以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做 **MAC 地址**。

每块网卡出厂的时候，都有一个全世界独一无二的 MAC 地址，长度是 48 个二进制位，通常用 12 个十六进制数表示。前 6 个十六进制数是厂商编号，后 6 个是该厂商的网卡流水号。如：`10:3d:3e:24:36:31`。

## 广播

有了 MAC 地址后，系统怎样才能把数据包准确送到接收方？

回答是以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。这种发送方式叫做**广播**。

# 网络层

互联网是无数子网络共同组成的一个巨型网络。但问题是，怎么区分哪些 MAC 地址属于同一个子网络，哪些不是？如果是同一个子网络，就采用广播方式发送，否则就采用"路由"方式发送。MAC 地址本身无法做到这一点。它只与厂商有关，与所处网络无关。

这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做"网络地址"，简称"网址"。

于是，"网络层"出现以后，每台计算机有了两种地址，一种是 MAC 地址，另一种是网络地址。两种地址之间没有任何联系，MAC 地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。

网络地址帮助我们确定计算机所在的子网络，MAC 地址则将数据包送到该子网络中的目标网卡。

功能：建立**主机**到**主机**的通信。

## IP（网际协议）

作用：为计算机分配 IP 地址，确定哪些 IP 地址在同一个子网络。

IP 协议第四版，简称 IPv4 。这个版本规定网络地址由 32 个二进制位组成。

习惯上，我们用分成四段的十进制数表示 IP 地址，从 0.0.0.0 一直到 255.255.255.255。

为了判断两个 IP 地址是否在同一子网络，除了 IP 地址，还需要子网掩码。

所谓"子网掩码"，就是表示子网络特征的一个参数。它在形式上等同于 IP 地址，也是一个 32 位二进制数字，它的网络部分全部为 1，主机部分全部为 0。比如，IP 地址 172.16.254.1，如果已知网络部分是前 24 位，主机部分是后 8 位，那么子网络掩码就是 11111111.11111111.11111111.00000000，写成十进制就是 255.255.255.0。

判断两个 IP 地址是否在同一子网络的方法：将两个 IP 地址与子网掩码分别进行 AND 运算（两个数位都为 1，运算结果为 1，否则为 0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。

### IP 数据包

根据 IP 协议发送的数据，就叫做 IP 数据包。IP 数据包也分为**首部**和**数据**两个部分。**首部**部分主要包括版本、长度、IP 地址等信息，**数据**部分则是 IP 数据包的具体内容。

IP 数据包是直接放进以太网数据包的**数据**部分。它放进以太网数据包后，以太网数据包就变成了下面这样。

| 以太网首部 | IP 首部 | 数据 |

IP 数据包的**首部**部分的长度为 20 到 60 字节，整个数据包的总长度最大为 65,535 字节。因此，理论上，一个 IP 数据包的**数据**部分，最长为 65,515 字节。以太网数据包的**数据**部分，最长只有 1500 字节。因此，如果 IP 数据包超过了 1500 字节，它就需要分割成几个以太网数据包，分开发送了。

### IP 地址分类

- A 类：1.0.0.0~126.255.255.255

  `0 网络地址 (7 位） 主机地址 (24 位）`

- B 类：128.0.0.0~191.255.255.255

  `10 网络地址 (14 位） 主机地址 (16 位）`

- C 类：192.0.0.0~223.255.255.255

  `110 网络地址 (21 位） 主机地址 (8 位）`

- D 类：224.0.0.0~239.255.255.255

  `1110 多目的广播地址 (28 位）`

- E 类：240.0.0.0~254.255.255.255

  `11110 保留用于实验和将来使用`

- 其中 127.0.0.0~127.255.255.255 用于环回测试，D 类地址用于组播，E 类地址用于科研。

私有 IP 地址只能在局域网内部使用，有：

| 地址类别 | 地址范围 | 网段个数 |
| --- | --- | --- |
| A 类 | 10.0.0.0 ~ 10.255.255.255 | 1 |
| B 类 | 172.16.0.0 ~ 172.31.255.255 | 16 |
| C 类 | 192.168.0.0 ~ 192.168.255.255 | 256 |

还有一些特殊地址：

| 网络号 | 主机号 | 用途 |
| --- | --- | --- |
| 全 1 | 全 1 | 即 255.255.255.255，本网广播地址（路由器不转发）。在本网络的目的地址写这个的话，就会内网广播 |
| 特定值 | 全 0 | 网络地址，表示一个网段|
| 特定值 | 全 1 | 直接广播地址，对特定网段上的所有主机进行广播 |
| 127 | 任何数（非全 0/1）| 用于本地软件环回测试 |

## ARP（地址解析协议）

功能：得到同一个子网络内的主机 MAC 地址。

从 IP 地址得到 MAC 地址有两种情况：

1. 第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的 MAC 地址，只能把数据包传送到两个子网络连接处的"网关"（gateway），让网关去处理。

2. 第二种情况，如果两台主机在同一个子网络，那么我们可以用 ARP 协议，得到对方的 MAC 地址。ARP 协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的 IP 地址，在对方的 MAC 地址这一栏，填的是 FF:FF:FF:FF:FF:FF，表示这是一个"广播"地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出 IP 地址，与自身的 IP 地址进行比较。如果两者相同，都做出回复，向对方报告自己的 MAC 地址，否则就丢弃这个包。

# 传输层

有了 MAC 地址和 IP 地址后，我们已经可以在互联网上的任意两台计算机间建立通信。

但还有一个问题是，同一台主机上有多个程序需要用到网络，如用浏览器访问网页，用聊天软件在线聊天，可是当主机接收到一个数据包时，怎么判断这个数据包是给浏览器用的，还是给聊天软件用的？

这时还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做"端口"，它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。

"端口"是 0 到 65535 之间的一个整数，正好 16 个二进制位。 0 到 1023 的端口被系统占用，用户只能选用大于 1023 的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。

只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix 系统就把主机+端口，叫做"套接字"（socket）。

功能：建立端口到端口的通信。

> 实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程。
>
> 如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。

## UDP（用户数据报协议）

特点：面向无连接，快速传输。

UDP 数据包，也是由**首部**和**数据**两部分组成。**首部**部分主要定义了发出端口和接收端口，**数据**部分就是具体的内容。**首部**部分共只有 8 个字节，总长度不超过 65,535 字节，正好放进一个 IP 数据包。

UDP 首部：

`| 16 位源端口号 | 16 位目的端口号 | 16 位 UDP 长度（是指 UDP 首部+数据的长度） | 16 位 UDP 校验和（用来校验首部和数据有错误） |`

然后，把整个 UDP 数据包放入 IP 数据包的**数据**部分，而前面说过，IP 数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：

| 以太网首部 | IP 首部 | UDP 首部 | 数据 |

## TCP（传输控制协议）

特点：基于字节流，面向连接，传输可靠。

- TCP 建立连接（三次握手）

  ![TCP_three_handshakes](./images/computer_network/TCP_three_handshakes.svg)

  - 第一次握手：客户端发送一个数据包告诉服务器要建立连接，无应用层数据。

    建立连接需要置 SYN 为 1 。seq 是客户端的初始序列号，是由 ISN 函数随机产生的数字。

    > 基于字节流的 TCP 其实每个字节的数据都有序号，在握手确认彼此的初始序列号之后，接下来所有的字节数据都是基于初始序列号向后累加的，初始序列号的生成方法就是 ISN 函数，它大概会随机生成一个数字，需要注意的是它的值并不是从 0 开始的。当一端发送了自己的初始序列号之后，并且收到了对端的 ack 就说明此次交互通畅，其中 ack 的值就是自己发过去的序列号加 1 。

    > `ISN = M + F(localhost, localport, remotehost, remoteport)
    >
    > M 是一个计时器，每隔 4 微秒加 1 。
    >
    > F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 hash 算法不能被外部轻易推算得出。
`

  - 第二次握手：服务器为该 TCP 连接**分配缓存和变量**，并向客户端返回一个确认报文，无应用层数据。

    SYN 置为 1 ，表示允许建立连接。ACK 置为 1，表示确认收到了发送方的包。seq 是服务器的初始序列号，也是随机产生的。ack 值为`ISN(c)+1`，表示接下来希望发送方要发的数据从`ISN(c)+1`开始。

  - 第三次握手：客户端为该 TCP 连接**分配缓存和变量**，并向服务器返回确认的确认，可以携带数据。

    ACK 置为 1，表示收到了服务器的确认请求。ack 值为 `ISN(s)+1`，表示接下来希望发送方要发的数据从`ISN(s)+1`开始。

- TCP 释放连接（四次挥手）

  ![TCP_four_waves](./images/computer_network/TCP_four_waves.svg)

  - 第一次挥手

    客户端发送连接释放报文，停止发送数据，主动关闭 TCP 连接。

    FIN 值为 1，表示此报文的发送方已经完成了数据的发送，没有新的数据要发送，并请求释放连接。

  - 第二次挥手

    客户端返回一个确认报文，客户端到服务器这个方向的连接就释放了。

    `seq=v`，v 的值取决于服务器发送给客户端之前的一个包确认号是多少。

  - 第三次挥手

    服务器发完数据后，发出连接释放报文，主动关闭 TCP 连接。

    `seq=w`，这里的 w 和上边的 v 不一定相等，因为这一步和上一步中间可能还在发送数据。

  - 第四次挥手

    客户端返回一个确认报文，再等到时间等待计时器设置的 2MSL（最长报文段寿命）后，连接彻底关闭。

- TCP 的重传机制

  由于 TCP 的下层网络（网络层）可能出现丢失、重复或失序的情况，TCP 协议提供可靠数据传输服务。为保证数据传输的正确性，TCP 会重传其认为已丢失（包括报文中的比特错误）的包。TCP 使用两套独立的机制来完成重传，一是基于时间，二是基于确认信息。TCP 在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的 ACK 确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。

UDP 和 TCP 的对比：
| | UDP | TCP |
| --- | --- | --- |
| 是否连接 | 无连接 | 面向连接 |
| 是否可靠 | 不可靠传输，不使用流量控制和拥塞控制 | 可靠传输，使用流量控制和拥塞控制 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信 |
| 传输方式 | 面向报文 | 面向字节流 |
| 首部开销 | 首部开销小，仅 8 字节 | 首部最小 20 字节，最大 60 字节 |
| 适用场景 | 适用于实时应用，例如视频会议、直播 | 适用于要求可靠传输的应用，例如文件传输 |

# 应用层

应用程序收到传输层的数据后，还需要对传来的数据进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。

**应用层的作用，就是规定应用程序的数据格式。**

举例来说，TCP 协议可以为各种各样的程序传递数据，比如 Email、WWW、FTP 等等。那么，必须有不同协议规定电子邮件、网页、FTP 数据的格式，这些应用程序协议就构成了"应用层"。

应用层的数据就放在 TCP 数据包的**数据**部分。因此，现在的以太网的数据包就变成下面这样：

| 以太网首部 | IP 首部 | TCP 首部 | 应用层数据包 |

## HTTP（超文本传输协议）

HTTP，Hypertext Transfer Protocol

### URI

URI, 全称为 (Uniform Resource Identifier), 也就是统一资源标识符，用于区分互联网上不同的资源。它具有两种形式，URN （统一资源名）、URL（统一资源定位符），也就是说 URL 和 URN 是它的子集。

URI 的结构：`scheme://user:paddwd@host:port/path?query#fragment`。

- `scheme` 表示协议名，比如 http, https, file 等等。后面必须和：//连在一起。
- `user:passwd@` 表示登录主机时的用户信息。
- `host:port` 表示主机名和端口。
- `path` 表示请求路径，标记资源所在位置。
- `query` 表示查询参数，为 key=val 这种形式，多个键值对之间用&隔开。
- `fragment` 表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。

URI 只能使用 ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。
如，空格被转义成了`%20`，三元被转义成了`%E4%B8%89%E5%85%83`。

### HTTP1.0

- HTTP 请求报文

  - 组成

    ![HTTP_request_message](./images/computer_network/HTTP_request_message.png)

        - 请求⾏

      请求⽅法字段、URL 字段、HTTP 协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。

        - 请求头部

      请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔  

        - 空行

        - 请求体

      post put 等请求携带的数据

  - 示例：
  
    ![Request_example](images/computer_network/Request_example.png)

- HTTP 响应报文

  - 组成

    ![HTTP_response_message](images/computer_network/HTTP_response_message.png)

        - 响应行

      由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK

        - 响应头

        - 空行

        - 响应体

      服务器响应的数据

### HTTP1.1

- HTTP1.0 和 HTTP1.1 采用不同的连接方式

  > HTTP 协议有两种连接模式，一种是持续连接（长连接），一种非持续连接（短连接）。
  >
  > - 非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。
  >
  > - 持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。

  - 在 HTTP/1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 `Connection: keep-alive` 来要求服务器不要关闭 TCP 连接。若想断开 keep-alive 连接，需发送`Connection:close`字段。

    <img src="images/computer_network/HTTP1.0_short_connection.png" style="zoom:65%"/>

  - 在 HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。如果需要关闭，需要客户端发送`Connection：close`首部字段。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。

    <img src="images/computer_network/HTTP1.1_long_connection.png" style="zoom:65%"/>

- 管道网络传输

  HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。

  >队头堵塞
  >
  >HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是 HTTP 队头阻塞问题。
  >
  >解决队头阻塞的方法：
  >
  > - **并发连接**：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。
  > - **域名分片**：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。

- 资源请求

  在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

- 缓存

  在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。

- 新增了 HOST 字段

  http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。

- 请求方法

  http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。

### HTTP2.0

- 二进制协议

  HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。

- 多路复用

  HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"的问题。

- 数据流

  HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。

- 头信息压缩

  HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。

  头部压缩算法：HTTP2 的头部压缩是 HPACK 算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到 50%~90%的高压缩率。

  - 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；

  - 首部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新；

  - 每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。

  例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。

  <img src="./images/computer_network/HPACK_example.png" style="zoom:70%"/>

- 服务器推送

  HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

### HTTP3.0

> HTTP/3 基于 UDP 协议实现了类似于 TCP 的多路复用数据流、传输可靠性等功能，这套功能被称为 QUIC 协议。

<img src="./images/computer_network/HTTP3.0_overview.png" style="zoom:80%"/>

- 流量控制、传输可靠性功能

  QUIC 在 UDP 的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些 TCP 中的特性。

- 集成 TLS 加密功能

  目前 QUIC 使用 TLS1.3，减少了握手所花费的 RTT 数。

- 多路复用

  同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了 TCP 的队头阻塞问题。

- 快速握手

  由于基于 UDP，可以实现使用 0 ~ 1 个 RTT 来建立连接。

## HTTPS（超文本传输安全协议）

HTTPS，Hypertext Transfer Protocol Secure

HTTPS 的默认端口是 443。

HTTPS 经由 HTTP 进行通信，利用 SSL/TLS 来加密数据包。HTTPS 的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。HTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议 TLS/SSL 具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。安全层的主要职责就是对发起的 HTTP 请求的数据进行加密操作和对接收到的 HTTP 的内容进行解密操作。

### TLS/SSL

SSL 协议（secure socket layer）在发展了几代之后，出现了更为安全的协议 TLS（transport layer security）。SSL 协议由于有安全隐患已经被淘汰了。

- TLS 握手过程

  ![HTTPS_TLS_handshakes](./images/computer_network/HTTPS_TLS_handshakes.svg)

  1. 客户端和服务端打招呼，并且把自己支持的 TLS 版本和加密套件（加密算法组合）发给服务器，同时还生成了一个随机数（第 1 随机数）给服务器。

  2. 服务器打招呼。服务端确认支持的 TLS 版本和选择的加密套件，并且也生成一个随机数（第 2 随机数）给客户端。

  3. 服务器发送证书给客户端。

  4. 服务器发送公钥给客户端。

  5. 服务器发送完毕后告知客户端。

  6. 客户端生成一个随机数（第 3 随机数，也叫预主密钥），用刚才接收的公钥对其进行加密，然后发送公钥加密过的随机数给服务器。而且客户端会用预主密钥、第 1 随机数和第 2 随机数计算出会话密钥。

     `Change Cipher Spec`的意思是告诉服务器往后的数据用商议好的算法和密钥来加密。`Encrypted Handshake Message`表示客户端这边的 TLS 协商已经没问题了。

  7. 服务器向客户端发送 `Encrypted Handshake Message`，表示服务器这边准备好了。服务器收到加密的预主密钥后会用私钥对其进行解密，然后用预主密钥、第 1 随机数和第 2 随机数计算出会话密钥。（客户端和服务器得到的会话密钥是相同的。后面的会话大家都会只使用这个会话密钥对数据进行加密。会话只应用在当前会话。）

## DNS（域名系统）

DNS，Domain name system

### DNS 同时使用 TCP 和 UDP 协议

DNS 占用 **53** 号端口，同时使用 TCP 和 UDP 协议。

- 在区域传输的时候使用 TCP 协议

  - 辅域名服务器会定时（一般 3 小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用 TCP 而不是 UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。

  - TCP 是一种可靠连接，保证了数据的准确性。

- 在域名解析的时候使用 UDP 协议

  - 客户端向 DNS 服务器查询域名，一般返回的内容都不超过 512 字节，用 UDP 传输即可。不用经过三次握手，这样 DNS 服务器负载更低，响应更快。理论上说，客户端也可以指定向 DNS 服务器查询时用 TCP，但事实上，很多 DNS 服务器进行配置的时候，仅支持 UDP 查询包。

### DNS 的查询方式

- 递归查询

  ![DNS_recursive_query](./images/computer_network/DNS_recursive_query.svg)

  递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。

- 迭代查询

  ![DNS_iterative_query](images/computer_network/DNS_iterative_query.svg)

  迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。

### DNS 的完整查询过程

![DNS_query_process](./images/computer_network/DNS_query_process.svg)

1. 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表。

2. 若没有命中，则继续搜索操作系统的 DNS 缓存。

3. 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果。

4. 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询。

   1. 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器。

   2. 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址。

   3. 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址。

5. 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来。

6. 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起。

7. 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起。

## WebSocket

WebSocket 是 HTML5 提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于 TCP 传输协议，并复用 HTTP 的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。

原理：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者 ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有 ID 在接收者 ID 序列中的客户端才会处理这个事件。

特点：

- 支持双向通信，实时性更强，相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少。

- 可以发送文本，也可以发送二进制数据。

- 数据格式比较轻量，性能开销小，通信高效。

- 没有同源限制，客户端可以与任意服务器通信。

- 协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。

- 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

应用场景：弹幕、媒体聊天、协同编辑、基于位置的应用、股票基金报价实时更新。

## CDN

CDN，Content Delivery Network，即内容分发网络。

### CDN 的基本原理

![CDN_process](./images/computer_network/CDN_process.svg)

1. 浏览器发起网络请求，经过本地 DNS 服务器解析，将域名解析权交给域名 CNAME 指向的 CDN 专用 DNS 服务器。

2. CDN 专用 DNS 服务器向浏览器返回 CDN 的全局负载系统的 IP。

3. 浏览器向 CDN 的全局负载系统发送网络请求。

4. CDN 的全局负载系统根据用户 IP 地址和请求的 URL ，选择一台用户所属区域的区域负载系统，向其发送请求。

5. CDN 的区域负载系统选择合适的 CDN 缓存服务器，将棋返回给 CDN 全局负载系统。

6. CDN 的全局负载系统将选中的 CDN 缓存服务器的 IP 地址返回给浏览器。

7. 浏览器向 CDN 缓存服务器发送请求，CDN 缓存服务器响应请求，返回相应的数据给浏览器。

# 附录一 常见请求头

- Accept：客户端可识别的内容类型列表。

- Accept-Charset: 浏览器能够显示的字符集

- Accept-Encoding：浏览器能够处理的压缩编码

- Accept-Language：浏览器当前设置的语言

- Connection：浏览器与服务器之间连接的类型

- Cookie：当前页面设置的任何 Cookie

- Host：请求的主机名，允许多个域名同处⼀个 IP 地址，即虚拟主机。

- Referer：发出请求的页面的 URL

- User-Agent：产⽣请求的浏览器类型。

# 附录二 常见响应头

- Date：表示消息发送的时间，时间的描述格式由 rfc822 定义

- server: 服务器名称

- Connection：浏览器与服务器之间连接的类型

- Cache-Control：控制 HTTP 缓存

- content-type: 表示后面的文档属于什么 MIME 类型

# 附录三 常见状态码

| 类别 | 原因 | 描述 |
| -- | -- | -- |
| 1xx | Informational（信息性状态码） | 接受的请求正在处理 |
| 2xx | Success（成功状态码） | 请求正常处理完毕 |
| 3xx | Redirection（重定向状态码） | 需要进行附加操作以完成请求 |
| 4xx | Client Error（客户端错误状态码） | 服务器无法处理请求 |
| 5xx | Server Error（服务器错误状态码） | 服务器处理请求出错 |

- 1xx

  - 100:（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应

  - 101：服务器根据客户端的请求切换协议，主要用于 websocket 或 http2 升级

- 2xx

  - 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回

- 3xx

  - 301（永久移动）：最新的 URI 为响应报文首部的 Location 字段。

  - 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

  - 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码

  - 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求，临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

- 4xx

  - 403（禁止）： 服务器拒绝请求
  - 404（未找到）： 服务器找不到请求的网页

- 5xx

  - 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应

# 参考资料

1. [互联网协议入门（一） - 阮一峰](https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html)

2. [互联网协议入门（二） - 阮一峰](https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html)

3. [What-happens-when 的中文翻译，原仓库](https://github.com/skyline75489/what-happens-when-zh_CN?utm_source=pocket_mylist#%E5%BD%93%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88)

4. [40 张图大揭秘：输入网址后到底发生了什么](https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ%3D%3D&abtest_cookie=AAACAA%3D%3D&ascene=14&chksm=fddece84caa94792e8f0eeef30cf7d225de5d9d36c00aeae36922e7dc50870dc87cde030a24e&devicetype=android-29&exportkey=A1VivFBmqLI%2FKyum4J7QnqA%3D&idx=2&lang=zh_CN&mid=2247489600&mpshare=1&nettype=WIFI&pass_ticket=yBQiDVQst41Fzso1arQHRyTSguydjpq8CX12ebyF5iKdYoz5R3N4v3rTW52V6u%2FT&scene=24&sharer_shareid=22d2e817fb338ac8ddf97fbc88b1abca&sharer_sharetime=1597418213930&sn=3a8253affdeca47a94ff3335be7bba67&srcid=0814AYP8m40Gwy8juzzqQWvC&utm_source=pocket_mylist&version=28001455&wx_header=3)
